#### 문제 풀이

[String Compression](https://leetcode.com/problems/string-compression/)

캐릭터 배열이 들어올 때 각 캐릭터의 개수를 세어 해당 캐릭터+그 수 로 압축할 때 생성되는 문자열의 길이를 리턴하는 문제다.
쉽게 보자면 "aabbc" 일 때 "a2b2c1" 으로 압축 가능하고 그 문자열의 길이 6 이 정답이 되는 것이다.

이렇게만 보면 참 쉬운 문제라 `easy` 네! 했지만 문제의 핵심은 문자열의 길이를 리턴하는 게 아니다.
바로 주어진 캐릭터의 배열을 그대로! 사용! 해서! 위의 압축된 문자열의 형태로! 만들면서 동시에 문자열의 길이를 리턴하는것이다!

즉 "aabbc" 일 때 "a2b2c1" 이라는 문자열을 주어진 배열의 요소를 바꿔치기 해가며 만들고 && 문자열의 길이를 리턴해야 한다.

이것때문에 easy 라고 보기엔 좀 어렵다. 그래서 downvote가 많은 것 같기도? 참고로 문제 대충 봐서 많이 틀리기도 했다 ㅠㅠ 이해하기도 좀 어려웠다.
만약 "abc" 라는 문자열이 오면 압축된 문자열은 "a1b1c1" 인데 이건 이미 주어진 캐릭터 배열의 사이즈를 넘어섰다. 이럴 경우는 어떻게 해야할지 몰라서 찾아봤더니, 
음 그냥 바꿔치기를 안하더라.

그래서 나도 똑같이 카운팅이 1이 나오면 무시하고 넘어갔다.


전체적으로 보자면 아래와 같다. 우선 start,end 라는 인덱스 두 개를 놓고 end 를 증가시켜 가며 `chars[start] == chars[end]` 를 비교한다. 비교하면서 count 도 세준다.
그러다가 다른 문자열 하나를 발견하면 루프를 빠져나와서 count 를 문자열로 바꿔서 `chars[start]` 의 바로 다음 글자 `chars[start++]` 에다가 집어넣었다.

그 이유는

a a b b c 라는 문자열이 있을 때 루프를 빠져나오면 start 는 0 이고 end 는 2다. 그러면 내가 센 count 2는 두번째 글자에다가 넣어주어야 하기 때문에 start를 하나 증가시킨것이다.
숫자가 10의 자리를 넘어서도 상관이 없다. count 를 문자열로 바꾸고 집어넣어도 충분히 남는다. (a의 개수가 10개 이상이어도 숫자에서 문자로 바꾸면 2자리고 그래서 a의 남는 자리에 집어넣기 가능)

이런식으로 문자열 바꿔치기 해주고 다시 `chars[start] = chars[end]` 로 엎어쳐준다. 

또 그 이유는

a a a b b c 일 때 위의 로직대로면 a 2 a b b c 가 되는데 이미 나의 end는 b 로 갔는데 start는 a를 못 벗어났다. 확인해야 할 문자열은 이제 b이기 때문에 그래서 
값을 엎어쳐줘서 마치 같은 곳을 가리키는 것 처럼 재 시작을 하는 것이다!


문자열 압축으로 보면 난이도 easy 이고, 주어진 배열을 그대로 사용하면 medium 에서 정답률 30% 정도 찍는 문제가 아닌가 싶다.