## 문제 설명
주어진 배열에서 중복된 수를 찾는 문제다.

## 솔루션
1. 정렬
정렬해서 인접한 두개 가 같다면 그 수가 답이다.

2. 맵 (또는 딕셔너리)
키에 수를 넣고 true,false (또는 exist, not exist) 를 배열을 순회하면서 체크하고 넣으면 된다.

위의 1,2 번으로만 풀면 문제는 easy 겠지만, 사실 이 문제는 medium 문제다.

3. binary search
바이너리 서치로 찾을 수도 있다.

4. 토끼와 거북이 알고리즘
토끼와 거북이 알고리즘에 대해 들어봤을 수도 있다. 영어로는 tortoise-hare 알고리즘으로 사이클을 찾을 수 있는 알고리즘 중 하다.
거북이는 느리게, 토끼는 빠르게 가다가 언젠간 둘이 만나게 된다면 이 자료 구조는 사이클임을 알 수 있다는 알고리즘 이다.

[참고](https://medium.com/@tuvo1106/the-tortoise-and-the-hare-floyds-algorithm-87badf5f7d41)

문제에서 이런 말이 있다.

```
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive)
```

1 ~ n 까지의 수가 n + 1 개 만큼의 배열에 있다는 의미다. 즉 배열의 수에서 최대 값은 n 은 배열의 크기 보다는 작게 된다.

사이클을 찾을 때 주어진 배열의 값들을 index 로 하여 리스트를 순회할 수 있는데, 이 때 필연적으로 같은 값들을 가르키게 되는 인덱스가 존재한다.
말이 어려운데, [1, 1, 2, 3] 이라고 했을 때 배열의 값 1은 각각 인덱스 0, 1 이고 인덱스 0과 1끼리는 사이클이 된다는 것이다.

문제에선 반드시 중복되는 수가 존재하기 때문에 배열은 무조건 사이클을 이룰 수 밖에 없다. 우리가 구하고자 하는 것은 사이클이 되는 배열의 값 (원소의 값) 인데 이 역시 토끼와 거북이 알고리즘으로 구할 수 있다.
앞서 말했듯이 토끼와 거북이 알고리즘은 사이클을 찾을 수 있는 알고리즘이면서 사이클의 시작 지점 또한 구할 수 있다.

> 사실 토끼와 거북이 알고리즘의 증명은 모르겠다. 그냥 그렇게 외웠다.

시작 지점은 거북이를 가장 처음 원소로 이동 시키고, 토끼와 거북이를 같은 속도로 이동 시키면 된다.

