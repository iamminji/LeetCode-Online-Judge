 #### 문제 풀이

[Reorganize String](https://leetcode.com/problems/reorganize-string/description/) 라는 문제다
난이도는 **Medium** 이다.

주어진 문자열 S의 순서를 바꾸어서 인접한 두 글자가 같지 않은 새로운 문자열을 리턴하는 문제다.
순서를 어떻게, 바꾸든 간에 무조건 인접한 두 글자가 같을 수 밖에 없다면 빈 문자열을 리턴하면 된다.

기존 문자열의 순서를 바꿀 때 인접한 두 글자가 같지 않으려면, 중간에 다른 글자가 있으면 된다.
이 의미는 곧 가운데 있을 글자의 수가 양 사이드에 있을 글자의 수 보다 적으면 되고. 
다르게 이야기 하면 문자열을 만들 때 가장 수가 많은 것 부터 차례대로 만들어 주면 된다.

Greedy 로 풀면 된다는 이야기이다.

먼저 파이썬에는 collections 모듈에 Counter라는 자료구조가 있는데, 별 건 아니고 dictionary 형태로 count 해주는 클래스다.
직접 세보아도 상관 없다. 어차피 내부적으로 O(n)으로 수행된다.

이 Counter를 이용해서 주어진 문자열 S의 <code>글자: 카운트</code> dictionary 를 만들고 이를 다시 heap 에 넣었다.

heap 에 넣어서 글자 수 많은 것 순으로 빼주면서 문자열을 만들 생각이기 때문이었다.
파이썬에서는 max-heap이 따로 없으므로 넣을 때 카운트 * -1 로 넣어주었다.

heappop 할 때는 두 글자씩 빼주었는데, 한 글자씩 빼면 처음 한 글자가 나머지 글자들의 카운트 보다 압도적으로 많을 시, 
그 다음 또 pop 해 주어도 또 그 글자가 나올 것이기 때문이다.

그러니까 예를 들면 다음과 같다. 문자열 <code>aaaabbc</code> 이 있다고 했을 때, a를 가장 먼저 결과 값에 넣고
하나만 뺐으므로 다시 a를 넣으면, a의 개수는 3으로 여전히 b나 c보다 많기 때문에 또 a가 결과 값에 추가 된다.
이러면 인접한 두 글자가 <code>aa</code>이므로 정답이 영영 안나오기 때문에 그래서 두 글자씩 빼주는 것이다.

이런식으로 두 글자씩 빼주고 가장 마지막에 결과 값에 넣었던 거랑 지금 첫 글자로 추가할 거랑 비교하는 예외처리 해주고,
카운트 값 -1 (여기선 min heap 이므로 +1) 해서 다시 heap 에 넣어주고 남은 글자가 2글자 미만일 때 까지 반복해주면 된다.


heap에 글자가 한 글자 남아있으면 결과 값에 추가해주고, 많이 남아있으면 빈 문자열을 바로 리턴해주었다.

시간 복잡도는 O(nlogn)이고, 공간복잡도도 O(n)이다.
