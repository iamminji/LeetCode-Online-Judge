 #### 문제 풀이

[Max Chunks To Make Sorted](https://leetcode.com/problems/max-chunks-to-make-sorted/description/) 라는 문제다
난이도는 **Medium** 이다.

주어진 리스트를 파티션을 나누고 각각을 정렬하여 다시 합칠 때, 그 합친 리스트가 정렬이 되어야 한다. 이 때, 나누는 파티션의 개수가 최대가 되는 개수를 리턴하는 문제이다.

(사실 구현을 어떻게 해야될 지 몰라 Discuss를 보았는데, 코드가 엄청 짧아서 깜짝 놀랐다.)

문제에서 리스트가 <code>[0, 1, ..., arr.length - 1]</code>로 주어지는데, 이 조건이 꽤 큰 힌트가 될 수 있다.
리스트가 정렬되려면 각각의 인덱스와 그 값이 같아야 한다는 것을 알 수 있기 때문이다.

예를 들어 arr이 <code>[4, 3, 1, 2, 0]</code>로 주어진 다고 한다면, 

첫 번째 인덱스 0의 값 4는 4번째 인덱스의 위치로 가야한다는 것을 알 수 있다. 그래야 정렬이 되었다고 볼 수 있기 때문이다.

그리고 두 번째 인덱스 1의 값 3의 위치는 마찬가지로 인덱스 3의 위치로 가야하는데, 이미 4라는 값을 4번째 인덱스에 위치했다고 본다면,
3은 4보다 작기 때문에 무시해도 된다. 

그러니까 다시 정리하자면, 인덱스 0의 값 4를 인덱스 4로 위치했다고 보고 인덱스 0 ~ 4 까지는 무조건 chunk 가 되어야 한다는 것을 알 수 있고.
인덱스 1의 값 3은 4 보다 작기 때문에 0 ~ 4 가 chunk로 나누어져 있을 때, 그 안에 포함 되어 있어서 카운트를 셀 필요가 없는 것이다.

이렇게 리스트를 순회 하면서 바꿔야할 가장 큰 값을 갱신해가며, 그 값과 인덱스가 같을 경우 +1 을 해주면 정답이 된다.
<code>[4, 3, 1, 2, 0]</code> 은 가장 큰 값으로 4를 갖고 있고, 이 4가 자신의 위치인 인덱스 4로 갔을 때 +1 을 해주면 그 사이의 값들이 한 chunk가 되기 때문이다.

Discuss를 안 봤으면 솔직히 엄청 노가다로, 어렵게 구했을 것 같은 문제였다.

시간 복잡도는 O(n)이고 공간 복잡도는 O(1)이다.
재밌는 문제였다.
