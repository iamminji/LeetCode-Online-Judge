#### 문제 풀이

내부 sort 함수를 사용하지 않고, 주어진 수 _0,1,2_ 를 정렬하는 문제입니다.

처음 아이디어는
1. 각 값에 대응하는 최소 인덱스(position) 3개를 두고 
2. 현재 num의 인덱스 값과 각각 대응하는 position의 대소 비교를 통하여
3. swap을 할 생각

틀린 것 같아서 그만 두고 다른 식으로 접근하였습니다.

아이디어는 비슷하면서도 다릅니다. position이 아니라 현재 값의 등장 횟수를 count 하였습니다.

1. 각 값에 해당하는 count 변수를 두고 등장 횟수를 세었습니다.
2. for 문을 한번 더 돌아서 앞에서부터 값을 채웠습니다.

값을 채우는 방식은 예를 들어 주어진 배열이 _[0, 1, 1, 0, 2]_ 라면 다음 처럼 동작합니다.

우선 c0에는 0의 개수인 2, c1은 2, c2는 1이 할당 됩니다.

가장 먼저 현재 인덱스가 0이 등장한 카운트 보다 적다면 앞에서 부터 2번 0을 채워줍니다.(카운트 값은 해당 수가 등장하는 가장 마지막 인덱스 + 1과 같습니다.)
 
그러면 현재 값은 _[0, 0, 1, 0, 2]_ 가 되죠.

1을 채워 넣는 경우는 0을 채우고(0의 마지막 인덱스가 지나고), 0과 1의 등장 횟수보다 (이 값은 마찬가지로 1의 마지막 인덱스 + 1과 같습니다.) 작은 경우만 확인하면 됩니다.

2는 그 외의 나머지의 경우만 채워주면 됩니다.


그리하여 for loop 두 번과 변수 3개로
- Time Complexity **O(n)**
- Space Complexity **O(1)** 

으로 풀 수 있는 문제였습니다.