#### 문제 풀이

[Binary Trees With Factors](https://leetcode.com/problems/binary-trees-with-factors/description/)


난이도는 Medium이다.


유니크한 숫자로 이루어진 리스트가 주어졌을 때, 만들 수 있는 트리의 개수를 리턴한다.
이 때, 트리는 부모 노드는 자식 노드의 곱셈이 되어야 하고 주어진 리스트에 있는 숫자는 중복되서 사용할 수 있어야 한다.


처음엔 리스트 인덱스로 주어진 리스트의 숫자 값을 사용하려고 했는데, 문제에서 A의 길이가 1000을 넘지 않고 A의 값들이 10 ^ 9 까지 온다고 하길래,
딕셔너리로 dp 자료형을 정했다.

그리고 나서 for loop를 돌리는데 1000 * 1000은 100만이므로 두 번 돌려도 될 것 같았다.


예제로 [2, 4, 8] 을 사용했다. 8이 2와 4로 이루어진 트리여야 되기 때문에 예외 케이스로 잡을 수 있을 것 같았다.


다시 문제로 보자면, [2, 4, 8] 일 경우 우선 생각해볼 수 있는게 각각의 숫자 값은 하나의 트리가 될 수 있으므로
<code>dp[값] = 1</code> 로 둘 수 있다.

그리고 나서 loop를 돌면서 계산해주는데 4의 경우엔 2 두개로 이루어질 수 있다. 이 때 좌/우 의 값이 바뀌어도 트리의 형태는 똑같다.
8로 보자면 8은 2와 4로 이루어져 있고 좌/우가 바뀌면 다른 트리가 된다.

이게 결국 경우의 수라서 8은 2,4로 이루어져있는데 4가 되는 경우의 수를 곱해주는 것이다.

그래서 dp[4] = dp[2] * dp[2] 이고 dp[8] = dp[2] * dp[4] 이다.
그런데 자기 자신도 포함하므로 += 으로 바뀌어지고 8은 4와 2로도 이루어져있을 수 있으니 다음 루프를 돌면서
dp[8] = dp[4] * dp[2] 도 계산하게 된다

아무튼 간에, 결과적으로 <code>dp[A[i]] += dp[A[j]] * dp[A[i] // A[j]]</code> 가 성립된다.

시간 복잡도는 전체 리스트의 길이가 N일때 O(N^2) 이 되고 

공간 복잡도는 dp 의 길이가 최대 1000이 될 것이므로 (A의 길이가 최대 1000) 상수로 생각할 수 있을 것 같다.
