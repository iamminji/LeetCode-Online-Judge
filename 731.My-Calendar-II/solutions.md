#### 문제 풀이

[My Calendar II](https://leetcode.com/problems/my-calendar-ii/description/)

난이도 **Medium** 구현 문제이다.

시작 시간과, 종료 시간을 입력으로 받고 해당하는 시간 대가 이미 두번 이상 존재하면 False를 리턴하고, 그렇지 않다면 True를 리턴해야 한다.

이와 같은 문제는 기존에 몇 번 풀어봐서 크게 어렵지 않았다. 보통 이런 문제는 start와 end를 기존의 시간 대에 포함 하는지 알아보아야 하는건데,
각각의 최대, 최소 값을 갱신해주면서 체크하면 된다.

우선 인스턴스로 리스트 두 개를 선언하고,
하나엔 전체 스케줄을 넣고 나머지 하나엔 현재까지 중복된 스케줄만 담는다.

중복된 스케줄 (이하 double_booked) 에 입력 받는 스케줄의 범위와 겹치면 False를 리턴한다.

범위와 겹치는지 판단할 때는, 시작 시간이 현재까지 있는 스케줄이 끝 시간 보다 작고 종료 시간이 그 시간의 시작 시간 보다 클 경우
각각의 최대 값, 최소 값을 넣어준다.

정리하자면 다음과 같다.

입력으로 아래와 같이 들어왔을 때
<pre><code>
MyCalendar.book(10, 20);
MyCalendar.book(50, 60);
</code></pre>

<pre>
1) |-------|
   10      20
2) |-------|  |------|
   10      20 50    60
</pre>

여기 까지는 겹치는 부분이 없다.
그러나 <code>MyCalendar.book(10, 40);</code> 가 들어오면

<pre>
|--------|
10       20
|---------------|
10              40
</pre>

이 때 double booked 는 (10, 20) 이다.

그러나 <code>MyCalendar.book(15, 30);</code> 이라고 하면

<pre>
|--------|
10       20
    |---------|
    15        30
</pre>

위 처럼 된다.
그러면 double booked는 (15, 20) 이다.

즉, 현재 스케줄의 값의 시작 지점과 들어오는 값의 시작 지점의 가장 큰 값, 현재 스케줄의 값의 종료 시점과
들어오는 값의 종료 시점 중 가장 작은 값이 double booked가 된다.

그래서 위 처럼 double booked에 있는지 먼저 체크하고 없으면 스케줄 값이랑 비교해서 double booked에 넣어주고
마지막으로 스케줄에 추가해주면, 세 번 들어왔는지는 확인할 수 있다.